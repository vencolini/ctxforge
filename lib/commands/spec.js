const fs = require('fs');
const path = require('path');
const { detectProjectType } = require('../utils/projectDetection');

/**
 * Extract feature name from description
 * @param {string} description - User description
 * @returns {string} Feature name
 */
function extractFeatureName(description) {
  const desc = description.toLowerCase();

  // Complex project detection
  if (desc.includes('blog') && desc.includes('website')) {
    if (desc.includes('astro')) return 'Astro.js Blog Website';
    if (desc.includes('next')) return 'Next.js Blog Website';
    if (desc.includes('gatsby')) return 'Gatsby Blog Website';
    return 'Blog Website';
  }

  // E-commerce detection
  if (desc.includes('ecommerce') || desc.includes('e-commerce') || desc.includes('shop')) {
    return 'E-commerce Platform';
  }

  // Multi-component systems
  if (desc.includes('deploy') && desc.includes('automation')) {
    return 'Automated Deployment System';
  }

  // Framework-specific projects
  if (desc.includes('astro')) return 'Astro.js Application';
  if (desc.includes('react') && desc.includes('app')) return 'React Application';
  if (desc.includes('vue') && desc.includes('app')) return 'Vue.js Application';

  // Feature-level detection
  if (desc.includes('search')) return 'Search Functionality';
  if (desc.includes('upload')) return 'File Upload';
  if (desc.includes('login') || desc.includes('auth')) return 'User Authentication';
  if (desc.includes('form')) return 'Form Input';
  if (desc.includes('dashboard')) return 'Dashboard Interface';
  if (desc.includes('api')) return 'API Integration';

  return 'Feature Implementation';
}

/**
 * Generate a basic behavioral specification
 * @param {string} description - User's feature description
 * @returns {string} Specification content
 */
function generateBasicSpec(description) {
  const featureName = extractFeatureName(description);
  const date = new Date().toISOString().split('T')[0];
  const projectInfo = detectProjectType();

  return `# Behavioral Specification: ${featureName}

**Created:** ${date}
**Generated by:** ctxforge specification generator
**Project Type:** ${projectInfo.type}
**Tech Stack:** ${projectInfo.framework} (${projectInfo.language})

## Context Analysis

**Original request:** "${description}"

**Note:** This is a template-based specification. Customize it based on your specific requirements.

## User Scenarios

### SCENARIO 1: Happy Path
\`\`\`gherkin
GIVEN user is on the main page
WHEN user interacts with the ${featureName.toLowerCase()}
THEN they should see the expected result
AND the feature should work as designed
\`\`\`

### SCENARIO 2: Error Handling
\`\`\`gherkin
GIVEN an error condition occurs
WHEN user attempts to use the feature
THEN appropriate error message is shown
AND user is guided to resolve the issue
\`\`\`

## Success Criteria

‚úÖ Feature works on first interaction
‚úÖ Error handling is user-friendly
‚úÖ Performance meets expectations
‚úÖ Accessible via keyboard navigation
‚úÖ Mobile-friendly responsive design

## Technical Implementation Notes

**Performance Directives to Apply:**
- Review docs/context/performance-directives/ for applicable directives
- Consider algorithmic efficiency (PD-ALGO-*)
- Implement proper error handling (PD-ERROR-*)
- Ensure accessibility compliance (PD-A11Y-*)

**Technology Stack Considerations:**
- Framework: ${projectInfo.framework}
- Language: ${projectInfo.language}
- Follow project-specific patterns in CONTEXT.md

## Next Steps

1. Review and customize this specification for your exact needs
2. Add specific user scenarios based on requirements
3. Define detailed success criteria
4. Implement following the task execution protocol
5. Document learnings in CONTEXT.md

---

*Generated by ctxforge v1.2.1*
*This is a template - customize based on your specific requirements*
`;
}

/**
 * Save specification to file
 * @param {string} specification - Spec content
 * @returns {string} File path
 */
function saveSpecification(specification) {
  // Ensure directory exists
  const specsDir = 'docs/context/behavioral-specs';
  if (!fs.existsSync(specsDir)) {
    fs.mkdirSync(specsDir, { recursive: true });
  }

  // Generate filename from feature name
  const featureName = specification.match(/# Behavioral Specification: (.+)/)?.[1] || 'generated-feature';
  const filename = featureName.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '.md';
  const filepath = path.join(specsDir, filename);

  // Save the specification
  fs.writeFileSync(filepath, specification);
  console.log(`   ‚úì Specification saved to: ${filepath}`);

  return filepath;
}

/**
 * Generate specification from user description
 * @param {string} description - Feature description
 */
function generateSpecification(description) {
  console.log('üìù ctxforge Specification Generation\n');
  console.log(`Analyzing request: "${description}"\n`);

  try {
    // Simple educational prompt
    const words = description.split(' ').length;
    if (words < 8) {
      console.log('üí° TIP: More detailed context usually leads to better specifications.');
      console.log('    Consider adding technology stack, scale, and UX requirements.');
      console.log('    Run "npx ctxforge context-help" for guidance.\n');
    }

    // Generate specification
    console.log('ü§ñ Generating behavioral specification...');
    const specification = generateBasicSpec(description);

    // Save it
    const filepath = saveSpecification(specification);

    console.log('\nüéâ Specification generation complete!\n');
    console.log('üìã Next steps:');
    console.log('1. Review the generated specification');
    console.log('2. Customize it for your specific needs');
    console.log('3. Start implementation with your LLM tool');
    console.log('4. Use "npx ctxforge validate" to ensure compliance');

  } catch (error) {
    console.log(`‚ùå Error generating specification: ${error.message}`);
    console.log('\nüí° Try providing more detail in your description or run "npx ctxforge validate" to check your setup.');
  }
}

module.exports = { generateSpecification, generateBasicSpec };
